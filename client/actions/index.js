import axios from 'axios';

export function showBanner(payload) {
    return {
        type: 'SHOW_BANNER',
        payload
    };
}

export function hideBanner() {
    return {
        type: 'HIDE_BANNER'
    };
}

export function setProductPickerOpen(isOpen) {
    return {
        type: 'SET_PICKER_MODAL_STATE',
        payload: isOpen
    };
}

const addProducts = (products, page, limit, search, filters) => {
    const opts = { params: { search, filters, page, limit } };
    return axios.post('/api/products', products, opts);
}

export function productsAddedSuccess(products) {
    return {
        type: 'ADD_SELECTED_PRODUCTS',
        payload: products
    };
}

export function addSelectedProducts(products, pageNum, pageSize, searchStr, filters) {
    return dispatch =>
        addProducts(products, pageNum, pageSize, searchStr, filters)
        .then(data => dispatch(productsAddedSuccess(data)))
        .then(() => {
            const message = 'The products you selected are now eligible for viewing in AR.'+
            ' Please add select product photos and add dimensions for each so they can be'+
            ' displayed in the augmented reality client';
            const bannerOpts = {
                status: 'success',
                title: 'Products added',
                message 
            };
            return dispatch(showBanner(bannerOpts));
        })
        .catch((err) => {
            console.log(err);
            const bannerOpts = {
                status: 'critical',
                title: 'Products could not be added',
                message: 'There was a problem adding these products. Please try again'
            };
            return dispatch(showBanner(bannerOpts));
        });
}

export function getProducts(search, limit, filters) {
    const opts = { params: { search, limit, filters } };
    return {
        type: 'GET_PRODUCTS',
        payload: axios.get('/api/products', opts)
    };
}

const updateFilters = (filters) =>
    Promise.resolve({
        type: 'SET_FILTERS',
        payload: filters
    });

export function handleFilterChange(filters, searchStr, pageSize) {
    return dispatch =>
        dispatch(updateFilters(filters))
        .then(() => dispatch(getProducts(searchStr, pageSize, filters)))
        .catch((err) => {
            console.log(err);
            const bannerOpts = {
                status: 'critical',
                title: 'Filtering Failure',
                message: 'There was a problem applying those filters. Please try again'
            };
            return dispatch(showBanner(bannerOpts));
        });
}

export function handlePagination(direction, pageNum, limit, search, filters) {
    const next = direction === 'next'; // direction is 'next' or 'prev'
    const page = next ? pageNum+1 : Math.max(pageNum-1, 0);
    const opts = { params: { search, filters, page, limit } };
    return {
        type: next ? 'NEXT_PAGE' : 'PREV_PAGE',
        payload: axios.get('/api/products', opts)
    }
}

export function setDeleteAlertOpen(opts) {
    return {
        type: 'OPEN_DELETE_ALERT',
        payload: opts
    };
}

const deleteProduct = (id, page, limit, search, filters) => {
    const opts = { params: { search, filters, page, limit } };
    return axios.delete(`/api/products/${id}`, opts);
}

export function updateProductsAfterDelete(payload) {
    return {
        type: 'DELETE_PRODUCT',
        payload
    }
}

export function deleteProductAndCloseModal(id, pageNum, pageSize, searchStr, filters) {
    return dispatch =>
        deleteProduct(id, pageNum, pageSize, searchStr, filters)
        .then(({ data }) => {
            return data.products.length ?
                { payload: { data } } :
                dispatch(handlePagination('prev', pageNum, pageSize, searchStr, filters));
        })
        .then(({ payload }) => {
            return dispatch(updateProductsAfterDelete(payload))
        })
        .then(() => dispatch(setDeleteAlertOpen({ isOpen: false, id: 0, title: '' })))
        .then(() => {
            const bannerOpts = {
                status: 'success',
                title: 'Delete Successful',
                message: 'Product Successfully deleted'
            };
            return dispatch(showBanner(bannerOpts));
        })
        .catch((err) => {
            console.log(err);
            const bannerOpts = {
                status: 'critical',
                title: 'Delete Failure',
                message: 'There was a problem deleting this product. Please try again'
            };
            return dispatch(showBanner(bannerOpts));
        });
}

export function updateProductAfterSaveEditForm(id, payload) {
    return {
        type: 'EDIT_FORM_SAVE',
        id,
        payload
    };
}

const updateProduct = (id, payload) => {
    // this will allow axios to recognize form generated by redux-form as a multipart form,
    // which is needed because this form contains a file
    const body = new FormData();
    Object.keys(payload).forEach(key => body.append(key, payload[key]));
    return axios.patch(`/api/products/${id}`, body);
};

export function saveEditForm(productId, payload) {
    return dispatch =>
        updateProduct(productId, payload)
        .then((payload) => dispatch(updateProductAfterSaveEditForm(productId, payload)))
        .then(() => {
            const bannerOpts = {
                status: 'success',
                title: 'Updated successful',
                message: 'Product Successfully updated'
            };
            return dispatch(showBanner(bannerOpts));
        })
        .catch((err) => {
            console.log(err);
            const bannerOpts = {
                status: 'critical',
                title: 'Update Failure',
                message: 'There was a problem updating this product. Please try again'
            };
            return dispatch(showBanner(bannerOpts));
        });
}

export function updateSearchField(searchStr) {
    return {
        type: 'UPDATE_SEARCH_FIELD',
        payload: searchStr
    }
}

export function setTypingTimeout(fn, delay) {
    return {
        type: 'SET_TYPING_TIMEOUT',
        payload: { fn, delay }
    }
}

export function searchProducts(searchStr, pageSize, filters) {
    return dispatch =>
        dispatch(getProducts(searchStr, pageSize, filters))
        .catch((err) => {
            console.log(err);
            const bannerOpts = {
                status: 'critical',
                title: 'Search Failure',
                message: 'There was a problem finding your products. Please try again'
            };
            return dispatch(showBanner(bannerOpts));
        });
}

export function clearTypingTimeout() {
    return {
        type: 'CLEAR_TYPING_TIMEOUT'
    };
}

// TODO: should I remove promise here?
export function changePage({id, title}, history) {
    return dispatch =>
        dispatch(Promise.resolve({
            type: 'CHANGE_PAGE',
            payload: { title }
        }))
        .then(() => history.push(`/products/${id}`))
}